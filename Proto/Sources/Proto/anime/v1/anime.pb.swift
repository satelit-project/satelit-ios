// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: anime/v1/anime.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Known anime types.
public enum Anime_V1_AnimeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case tv // = 0
  case ova // = 1
  case ona // = 2
  case movie // = 3
  case special // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .tv
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tv
    case 1: self = .ova
    case 2: self = .ona
    case 3: self = .movie
    case 4: self = .special
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tv: return 0
    case .ova: return 1
    case .ona: return 2
    case .movie: return 3
    case .special: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anime_V1_AnimeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anime_V1_AnimeType] = [
    .tv,
    .ova,
    .ona,
    .movie,
    .special,
  ]
}

#endif  // swift(>=4.2)

/// Airing status of a single anime show.
public enum Anime_V1_AiringStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unaired // = 0
  case airing // = 1
  case aired // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unaired
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unaired
    case 1: self = .airing
    case 2: self = .aired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unaired: return 0
    case .airing: return 1
    case .aired: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anime_V1_AiringStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anime_V1_AiringStatus] = [
    .unaired,
    .airing,
    .aired,
  ]
}

#endif  // swift(>=4.2)

/// Name of the season when an anime show started airing.
public enum Anime_V1_AiringSeason: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case summer // = 0
  case fall // = 1
  case winter // = 2
  case spring // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .summer
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .summer
    case 1: self = .fall
    case 2: self = .winter
    case 3: self = .spring
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .summer: return 0
    case .fall: return 1
    case .winter: return 2
    case .spring: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Anime_V1_AiringSeason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Anime_V1_AiringSeason] = [
    .summer,
    .fall,
    .winter,
    .spring,
  ]
}

#endif  // swift(>=4.2)

/// Represents anime genre.
///
/// Default locale is en-US.
public struct Anime_V1_AnimeGenre {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Genre identifier.
  public var id: UInt64 = 0

  /// Genre name.
  public var name: String = String()

  /// Genre summary.
  public var summary: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single anime show.
///
/// Default locale is en-US.
public struct Anime_V1_Anime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Show's identifier.
  public var id: UInt64 = 0

  /// Name of the show in romanji.
  public var name: String = String()

  /// URL of the poster.
  public var posterURL: String = String()

  /// URL of the poster thumbnail.
  public var thumbnailURL: String = String()

  /// Type of the show.
  public var type: Anime_V1_AnimeType = .tv

  /// Airing season.
  public var season: Anime_V1_AiringSeason = .summer

  /// Airing status.
  public var airingStatus: Anime_V1_AiringStatus = .unaired

  /// Timestamp of when the show started airing.
  public var startAiringDate: UInt64 = 0

  /// Timestamp of when the show ended airing.
  public var endAiringDate: UInt64 = 0

  /// Score from 0 to 10.
  public var score: Float = 0

  /// List of the show's genres.
  public var genres: [Anime_V1_AnimeGenre] = []

  /// Summary of the show.
  public var summary: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "anime.v1"

extension Anime_V1_AnimeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANIME_TYPE_TV"),
    1: .same(proto: "ANIME_TYPE_OVA"),
    2: .same(proto: "ANIME_TYPE_ONA"),
    3: .same(proto: "ANIME_TYPE_MOVIE"),
    4: .same(proto: "ANIME_TYPE_SPECIAL"),
  ]
}

extension Anime_V1_AiringStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AIRING_STATUS_UNAIRED"),
    1: .same(proto: "AIRING_STATUS_AIRING"),
    2: .same(proto: "AIRING_STATUS_AIRED"),
  ]
}

extension Anime_V1_AiringSeason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AIRING_SEASON_SUMMER"),
    1: .same(proto: "AIRING_SEASON_FALL"),
    2: .same(proto: "AIRING_SEASON_WINTER"),
    3: .same(proto: "AIRING_SEASON_SPRING"),
  ]
}

extension Anime_V1_AnimeGenre: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnimeGenre"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.summary)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anime_V1_AnimeGenre, rhs: Anime_V1_AnimeGenre) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Anime_V1_Anime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Anime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "poster_url"),
    4: .standard(proto: "thumbnail_url"),
    5: .same(proto: "type"),
    6: .same(proto: "season"),
    7: .standard(proto: "airing_status"),
    8: .standard(proto: "start_airing_date"),
    9: .standard(proto: "end_airing_date"),
    10: .same(proto: "score"),
    11: .same(proto: "genres"),
    12: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.posterURL)
      case 4: try decoder.decodeSingularStringField(value: &self.thumbnailURL)
      case 5: try decoder.decodeSingularEnumField(value: &self.type)
      case 6: try decoder.decodeSingularEnumField(value: &self.season)
      case 7: try decoder.decodeSingularEnumField(value: &self.airingStatus)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.startAiringDate)
      case 9: try decoder.decodeSingularUInt64Field(value: &self.endAiringDate)
      case 10: try decoder.decodeSingularFloatField(value: &self.score)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.genres)
      case 12: try decoder.decodeSingularStringField(value: &self.summary)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.posterURL.isEmpty {
      try visitor.visitSingularStringField(value: self.posterURL, fieldNumber: 3)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 4)
    }
    if self.type != .tv {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if self.season != .summer {
      try visitor.visitSingularEnumField(value: self.season, fieldNumber: 6)
    }
    if self.airingStatus != .unaired {
      try visitor.visitSingularEnumField(value: self.airingStatus, fieldNumber: 7)
    }
    if self.startAiringDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.startAiringDate, fieldNumber: 8)
    }
    if self.endAiringDate != 0 {
      try visitor.visitSingularUInt64Field(value: self.endAiringDate, fieldNumber: 9)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 10)
    }
    if !self.genres.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.genres, fieldNumber: 11)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Anime_V1_Anime, rhs: Anime_V1_Anime) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.posterURL != rhs.posterURL {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.season != rhs.season {return false}
    if lhs.airingStatus != rhs.airingStatus {return false}
    if lhs.startAiringDate != rhs.startAiringDate {return false}
    if lhs.endAiringDate != rhs.endAiringDate {return false}
    if lhs.score != rhs.score {return false}
    if lhs.genres != rhs.genres {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
